<!doctype html>
<html lang="fr">
<head>
  <head>
  <meta charset="UTF-8">
  <title>Volt Clash</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Press+Start+2P&display=swap" rel="stylesheet">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Combat Électrique — V4 Final (30×30)</title>
  <style>
    body { margin:0; background:#111; color:#eee; font-family:system-ui, Arial, sans-serif; }
    .wrap { max-width: 1450px; margin: 0 auto; padding: 16px; }
    .top { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .panel { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .badge { padding:6px 10px; border:1px solid #333; border-radius:999px; background:#151515; font-size:14px; }
    button {
      padding:8px 10px; border-radius:10px; border:1px solid #333;
      background:#1b1b1b; color:#eee; cursor:pointer;
    }
    button:hover { background:#222; }
    .note { color:#cfcfcf; font-size:14px; line-height:1.45; margin:10px 0 12px 0; }
    .sheet { background:#0b0b0b; border:1px solid #333; border-radius: 10px; padding: 12px; }
    canvas { width: 1040px; max-width: 100%; height: auto; display:block; background:#0b0b0b; border-radius:8px; }
    .help { margin-top:10px; color:#cfcfcf; font-size:13px; line-height:1.55; }
    .warn { color:#ffcf7a; }
    .ok { color:#9dffb6; }
    code { background:#1b1b1b; padding:2px 6px; border-radius:6px; border:1px solid #2b2b2b; }

    .players { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pchip { padding:6px 10px; border-radius:999px; border:1px solid #333; background:#151515; font-size:13px; display:flex; align-items:center; gap:8px; }
    .dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
    select { background:#151515; color:#eee; border:1px solid #333; border-radius:8px; padding:4px 8px; }

    /* Banner animation */
    .banner {
      position: fixed;
      left: 50%; top: 18%;
      transform: translate(-50%, -50%);
      background: rgba(10,10,10,0.92);
      border: 1px solid #333;
      border-radius: 14px;
      padding: 14px 18px;
      min-width: 360px;
      text-align: center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      box-shadow: 0 12px 40px rgba(0,0,0,0.45);
    }
    .banner.show { animation: pop 1.35s ease forwards; }
    .banner .title { font-weight: 850; font-size: 20px; margin-bottom: 6px; }
    .banner .sub { font-size: 13px; color: #cfcfcf; }
    @keyframes pop {
      0% { opacity: 0; transform: translate(-50%, -60%) scale(0.96); }
      18% { opacity: 1; transform: translate(-50%, -50%) scale(1.03); }
      65% { opacity: 1; transform: translate(-50%, -50%) scale(1.00); }
      100% { opacity: 0; transform: translate(-50%, -44%) scale(0.99); }
    }
  </style>
</head>
<body>

<div id="banner" class="banner">
  <div class="title" id="bTitle"></div>
  <div class="sub" id="bSub"></div>
</div>

<div class="wrap">
  <div class="top">
    <h2 style="margin:0;">Volt Clash — V4 Final (4 joueurs, 30×30)</h2>
    <div class="panel">
      <span class="badge" id="turn">Joueur: A</span>
      <span class="badge" id="moves">Coups restants: 5</span>
      <button id="endturn">W = Fin de tour</button>
      <button id="reset">Réinitialiser</button>
      <button id="togglebg">Fond: Noir</button>
      <button id="toggleExpert">IA: Normal</button>
    </div>
  </div>

  <div class="note">
    <b>Commandes :</b>
    <code>o</code>=haut, <code>l</code>=bas, <code>k</code>=gauche, <code>m</code>=droite,
    <code>Espace</code>=valider, <code>w</code>=fin de tour.<br/>
    <b>Règle élimination :</b> un joueur est éliminé <b>uniquement</b> si un adversaire pose une <b>CROIX</b> sur un nœud de sa <b>base</b>.<br/>
    <b>Départ :</b> une croix est posée automatiquement sur le nœud adjacent “diagonale vers le centre” pour chaque joueur.
  </div>

  <div class="players" id="playersRow"></div>

  <div class="sheet">
    <canvas id="c"></canvas>
  </div>

  <div class="help" id="status"></div>
</div>

<script>
(() => {
  // ----------------------------
  // Config
  // ----------------------------
  const GRID_CELLS = 30;
  const NODES = GRID_CELLS + 1;
  const BASE_CELLS = 2;          // base = 3x3 nœuds
  const MOVES_PER_TURN = 5;

  const CELL_PX = 22;
  const MARGIN_PX = 24;

  // Halo plus intense
  const HALO_WIDE = 11;
  const HALO_THIN = 3.4;
  const HALO_ALPHA_WIDE = 0.22;
  const HALO_ALPHA_THIN = 0.38;

  // IA: seuil de "menace" (défense si ennemi trop proche de la base)
  const DEFENSE_RADIUS = 7;              // en nœuds (Manhattan approximé via dist2)
  const DEFENSE_RADIUS2 = DEFENSE_RADIUS * DEFENSE_RADIUS;

  // IA: zone bouclier autour de base (nœuds proches à privilégier)
  const SHIELD_RADIUS = 5;
  const SHIELD_RADIUS2 = SHIELD_RADIUS * SHIELD_RADIUS;

  const PLAYERS = [
    { id:"A", color:"#ff5d5d", name:"A (Rouge)" }, // TL
    { id:"B", color:"#3ddc84", name:"B (Vert)"  }, // BR
    { id:"C", color:"#ffd84d", name:"C (Jaune)" }, // TR
    { id:"D", color:"#4da6ff", name:"D (Bleu)"  }, // BL
  ];

  // Par défaut : 1 humain + 3 IA
  const control = new Map([
    ["A", "HUMAN"],
    ["B", "AI"],
    ["C", "AI"],
    ["D", "AI"],
  ]);



// ----------------------------
// Mode IA Expert (Beam Search) — toggle
// ----------------------------
let expertMode = false; // false = IA normale (scoring simple), true = Beam Search
const AI_BEAM = {
  depth: 3,           // lookahead (coups simulés du même joueur dans son tour)
  beamWidth: 18,      // K
  maxBranch: 50,      // top-N coups évalués par niveau
  wAttack: 1.0,
  wDefense: 0.25,
  tieNoise: 0.02      // brise les égalités
};
// ----------------------------
// IA profiles (styles différents)
// ----------------------------
// Chaque IA reçoit un profil distinct au reset, pour éviter les schémas identiques en début de partie.
// Les profils influencent : choix de cible, appétence CROSS vs CIRCLE, et mélange diagonale/ligne.
const AI_PROFILE_DEFS = {
  RAIDER:    { name:"RAIDER",    circleBiasAttack: 0.08, circleBiasDefense: 0.55, diagWeight: 0.55, lineWeight: 1.10, targetMode: "HUMAN_FIRST", noise: 1400 },
  BALANCED:  { name:"BALANCED",  circleBiasAttack: 0.12, circleBiasDefense: 0.62, diagWeight: 0.70, lineWeight: 1.00, targetMode: "NEAREST",     noise: 1200 },
  SWARM:     { name:"SWARM",     circleBiasAttack: 0.10, circleBiasDefense: 0.58, diagWeight: 0.85, lineWeight: 0.92, targetMode: "WEAKEST",     noise: 1700 },
  SIEGER:    { name:"SIEGER",    circleBiasAttack: 0.06, circleBiasDefense: 0.50, diagWeight: 0.45, lineWeight: 1.20, targetMode: "RANDOM_ROTATE", noise: 1500 },
};
const aiProfile = new Map();          // pid -> profile object
const aiTargetOverride = new Map();   // pid -> targetPid (pour RANDOM_ROTATE)

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function assignAIProfiles(){
  const pool = shuffle(Object.keys(AI_PROFILE_DEFS).slice());
  for (const p of PLAYERS){
    if (control.get(p.id) !== "AI") continue;
    const key = pool.length ? pool.pop() : "BALANCED";
    aiProfile.set(p.id, AI_PROFILE_DEFS[key]);
    aiTargetOverride.delete(p.id);
  }
  // Si plusieurs IA et pool insuffisant, on mélange quand même via noise/target rotate.
}

function marksCount(pid){
  let c = 0;
  for (const m of marks.values()) if (m.owner === pid) c++;
  return c;
}

function chooseTargetPid(pid, prof){
  const aliveEnemies = PLAYERS.map(p => p.id).filter(id => id !== pid && alive.get(id));
  if (!aliveEnemies.length) return null;

  if (prof.targetMode === "HUMAN_FIRST"){
    if (alive.get("A") && pid !== "A") return "A";
    // fallback nearest
  }

  if (prof.targetMode === "WEAKEST"){
    let best = null, bestVal = Infinity;
    for (const eid of aliveEnemies){
      const v = marksCount(eid); // moins de présence => plus faible
      if (v < bestVal) { bestVal = v; best = eid; }
    }
    return best || aliveEnemies[0];
  }

  if (prof.targetMode === "RANDOM_ROTATE"){
    // Garde une cible quelques tours : évite que toutes les IA convergent pareil
    const keep = aiTargetOverride.get(pid);
    if (keep && alive.get(keep)) return keep;
    const pick = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
    aiTargetOverride.set(pid, pick);
    return pick;
  }

  // NEAREST (par défaut)
  const selfStart = startNodeFor(pid);
  let best = null, bestD2 = Infinity;
  for (const eid of aliveEnemies){
    const c = baseCenter(eid);
    const d2 = dist2(selfStart, c);
    if (d2 < bestD2) { bestD2 = d2; best = eid; }
  }
  return best || aliveEnemies[0];
}

function opponentTargetPoint(pid, prof) {
  const p = prof || aiProfile.get(pid) || AI_PROFILE_DEFS.BALANCED;
  const tPid = chooseTargetPid(pid, p);
  return tPid ? baseCenter(tPid) : { ix: Math.floor(NODES/2), iy: Math.floor(NODES/2) };
}

  
  // ----------------------------
  // Plateau background (toggle noir/blanc)
  // ----------------------------
  let boardBg = "#0b0b0b"; // fond actuel du plateau
  function toggleBoardBg(){
    boardBg = (boardBg === "#0b0b0b") ? "#ffffff" : "#0b0b0b";
    updateBgButton();
    const exBtn = document.getElementById('toggleExpert');
    if (exBtn) exBtn.textContent = expertMode ? 'IA: Expert' : 'IA: Normal';
    requestRedraw();
  }
  function updateBgButton(){
    const btn = document.getElementById("togglebg");
    if (!btn) return;
    btn.textContent = (boardBg === "#0b0b0b") ? "Fond: Noir" : "Fond: Blanc";
  }
  // Toggle Expert AI (Beam Search)
  function toggleExpertMode(){
    expertMode = !expertMode;
    const btn = document.getElementById("toggleExpert");
    if (btn) btn.textContent = expertMode ? "IA: Expert" : "IA: Normal";
    message = expertMode ? "Mode Expert (Beam) activé." : "Mode Normal activé.";
    setBadges();
    requestRedraw();
    // si c'est au tour d'une IA, relancer proprement
    if (!gameOver && control.get(currentPlayerId()) === "AI") scheduleAITick(110);
  }


// ----------------------------
  // Banner
  // ----------------------------
  const banner = document.getElementById("banner");
  const bTitle = document.getElementById("bTitle");
  const bSub = document.getElementById("bSub");
  let bannerTimer = null;
  function showBanner(title, sub, color="#eee") {
    bTitle.textContent = title;
    bSub.textContent = sub || "";
    bTitle.style.color = color;
    banner.classList.remove("show");
    void banner.offsetWidth;
    banner.classList.add("show");
    clearTimeout(bannerTimer);
    bannerTimer = setTimeout(() => banner.classList.remove("show"), 1400);
  }

  // ----------------------------
  // Geometry
  // ----------------------------
 function baseRectFor(pid){
  switch(pid){
    case "A": return { ix: 0, iy: 0, cells: BASE_CELLS };
    case "B": return { ix: NODES - BASE_CELLS - 1, iy: NODES - BASE_CELLS - 1, cells: BASE_CELLS };
    case "C": return { ix: NODES - BASE_CELLS - 1, iy: 0, cells: BASE_CELLS };
    case "D": return { ix: 0, iy: NODES - BASE_CELLS - 1, cells: BASE_CELLS };
  }
}
  function baseCenter(pid){
    const b = baseRectFor(pid);
    return { ix: b.ix + 1, iy: b.iy + 1 }; // centre du 3x3
  }
  function startNodeFor(pid){
    // nœud adjacent vers centre (diagonale)
    const b = baseRectFor(pid);
    const step = b.cells + 1; // 3
    if (pid === "A") return { ix: b.ix + step, iy: b.iy + step };
    if (pid === "B") return { ix: b.ix - 1,    iy: b.iy - 1 };
    if (pid === "C") return { ix: b.ix - 1,    iy: b.iy + step };
    if (pid === "D") return { ix: b.ix + step, iy: b.iy - 1 };
    return { ix: 0, iy: 0 };
  }

  // ----------------------------
  // Canvas
  // ----------------------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;

  const displayW = MARGIN_PX*2 + GRID_CELLS * CELL_PX;
  const displayH = MARGIN_PX*2 + GRID_CELLS * CELL_PX;

  canvas.style.width = displayW + "px";
  canvas.style.height = displayH + "px";
  canvas.width = Math.round(displayW * dpr);
  canvas.height = Math.round(displayH * dpr);
  ctx.scale(dpr, dpr);

  function nodeToPx(ix, iy) { return { x: MARGIN_PX + ix * CELL_PX, y: MARGIN_PX + iy * CELL_PX }; }
  function keyOf(ix, iy) { return `${ix},${iy}`; }
  function parseKey(k) { const [ix,iy] = k.split(",").map(Number); return {ix,iy}; }
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function dist2(a,b){ const dx=a.ix-b.ix, dy=a.iy-b.iy; return dx*dx+dy*dy; }

  // ----------------------------
  // Mouse -> node (snap)
  // ----------------------------
  function mouseToNode(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const ix = clamp(Math.round((x - MARGIN_PX) / CELL_PX), 0, NODES - 1);
    const iy = clamp(Math.round((y - MARGIN_PX) / CELL_PX), 0, NODES - 1);
    return { ix, iy };
  }


  const dirs8 = [
    {dx: 1, dy: 0}, {dx:-1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy:-1},
    {dx: 1, dy: 1}, {dx: 1, dy:-1}, {dx:-1, dy: 1}, {dx:-1, dy:-1},
  ];
  const neigh4 = [
    {dx: 1, dy: 0}, {dx:-1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy:-1},
  ];

  // ----------------------------
  // State
  // ----------------------------
  const marks = new Map(); // nodeKey -> { owner, kind:"X"|"O" }
  const walls = new Map(); // edgeKey -> owner (derived from O-O)

  const alive = new Map(PLAYERS.map(p => [p.id, true]));
  const started = new Map(PLAYERS.map(p => [p.id, false]));

  let currentIdx = 0;
  let movesLeft = MOVES_PER_TURN;
  let message = "";
  let gameOver = false;

  const cursors = new Map(PLAYERS.map(p => [p.id, { ...startNodeFor(p.id) } ]));

  function playerById(pid){ return PLAYERS.find(p => p.id === pid); }
  function currentPlayerId(){ return PLAYERS[currentIdx].id; }
  function currentPlayer(){ return playerById(currentPlayerId()); }
  function activeCursor(){ return cursors.get(currentPlayerId()); }

  // IA scheduler (anti-blocage)
  let aiTimer = null;
  function stopAI() {
    if (aiTimer) { clearTimeout(aiTimer); aiTimer = null; }
  }

  // ----------------------------
  // Base helpers
  // ----------------------------
  function inBase(ix, iy, base) {
    return ix >= base.ix && ix <= base.ix + base.cells && iy >= base.iy && iy <= base.iy + base.cells;
  }
  function isOwnBase(pid, ix, iy){
    if (!alive.get(pid)) return false;
    return inBase(ix, iy, baseRectFor(pid));
  }
  function baseOwnerAt(ix, iy) {
    for (const p of PLAYERS) {
      if (!alive.get(p.id)) continue;
      if (inBase(ix, iy, baseRectFor(p.id))) return p.id;
    }
    return null;
  }

  // ----------------------------
  // Walls
  // ----------------------------
  function edgeKey(a, b) {
    const k1 = keyOf(a.ix, a.iy);
    const k2 = keyOf(b.ix, b.iy);
    return (k1 < k2) ? `${k1}|${k2}` : `${k2}|${k1}`;
  }

  function rebuildWallsFromCircles() {
    walls.clear();
    for (const [k, m] of marks.entries()) {
      if (m.kind !== "O") continue;
      const a = parseKey(k);
      for (const d of neigh4) {
        const b = { ix: a.ix + d.dx, iy: a.iy + d.dy };
        if (b.ix < 0 || b.iy < 0 || b.ix >= NODES || b.iy >= NODES) continue;
        const mb = marks.get(keyOf(b.ix, b.iy));
        if (!mb) continue;
        if (mb.kind === "O" && mb.owner === m.owner) {
          walls.set(edgeKey(a, b), m.owner);
        }
      }
    }
  }

  function isBlockedByEnemyWall(from, to, pid, dx, dy) {
    const isOrth = (Math.abs(dx) + Math.abs(dy)) === 1;
    if (!isOrth) return false;
    const ek = edgeKey(from, to);
    const owner = walls.get(ek);
    if (!owner) return false;
    return owner !== pid;
  }

  // ----------------------------
  // Conduction model
  // ----------------------------
  function conductiveForPlayer(ix, iy, pid) {
    const k = keyOf(ix, iy);
    const m = marks.get(k);
    if (m && m.owner === pid) return true;
    if (!alive.get(pid)) return false;
    return inBase(ix, iy, baseRectFor(pid));
  }

  function computePoweredSet(pid) {
    const powered = new Set();
    const q = [];
    if (!alive.get(pid)) return powered;

    const base = baseRectFor(pid);
    for (let y = base.iy; y <= base.iy + base.cells; y++) {
      for (let x = base.ix; x <= base.ix + base.cells; x++) {
        const k = keyOf(x, y);
        powered.add(k);
        q.push({ix:x, iy:y});
      }
    }

    while (q.length) {
      const cur = q.shift();
      for (const d of dirs8) {
        const nx = cur.ix + d.dx;
        const ny = cur.iy + d.dy;
        if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;

        if (!conductiveForPlayer(nx, ny, pid)) continue;
        if (isBlockedByEnemyWall(cur, {ix:nx, iy:ny}, pid, d.dx, d.dy)) continue;

        const nk = keyOf(nx, ny);
        if (powered.has(nk)) continue;
        powered.add(nk);
        q.push({ix:nx, iy:ny});
      }
    }
    return powered;
  }

  function hasAdjacentFriendlyOrBase(pid, ix, iy) {
    if (!alive.get(pid)) return false;
    const base = baseRectFor(pid);
    for (const d of dirs8) {
      const nx = ix + d.dx, ny = iy + d.dy;
      if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
      if (inBase(nx, ny, base)) return true;
      const m = marks.get(keyOf(nx, ny));
      if (m && m.owner === pid) return true;
    }
    return false;
  }

  // ----------------------------
  // Move legality
  // ----------------------------
  function canPlaceCross(pid, ix, iy) {
    if (gameOver || !alive.get(pid)) return false;
    const k = keyOf(ix, iy);
    if (marks.has(k)) return false;
    if (isOwnBase(pid, ix, iy)) return false;

    // must remain powered after placement
    marks.set(k, { owner: pid, kind:"X" });
    rebuildWallsFromCircles();
    const powered = computePoweredSet(pid);
    const ok = powered.has(k);
    marks.delete(k);
    rebuildWallsFromCircles();
    return ok;
  }

  function canCircle(pid, targetKey) {
    if (gameOver || !alive.get(pid)) return false;
    const t = marks.get(targetKey);
    if (!t) return false;
    if (t.owner === pid) return false;
    if (t.kind !== "X") return false;

    const {ix, iy} = parseKey(targetKey);
    if (!hasAdjacentFriendlyOrBase(pid, ix, iy)) return false;

    marks.set(targetKey, { owner: pid, kind:"O" });
    rebuildWallsFromCircles();
    const powered = computePoweredSet(pid);
    const ok = powered.has(targetKey);
    marks.set(targetKey, t);
    rebuildWallsFromCircles();
    return ok;
  }

  function placeCross(pid, ix, iy) {
    const k = keyOf(ix, iy);
    marks.set(k, { owner: pid, kind:"X" });
    started.set(pid, true);
    rebuildWallsFromCircles();
    return { ix, iy, key:k, kind:"X" };
  }

  function placeCircle(pid, key) {
    marks.set(key, { owner: pid, kind:"O" });
    started.set(pid, true);
    rebuildWallsFromCircles();
    const {ix, iy} = parseKey(key);
    return { ix, iy, key, kind:"O" };
  }

  // ----------------------------
  // Elimination (base by CROSS only)
  // ----------------------------
  function transferEliminatedPieces(elimPid, winnerPid) {
    for (const [k, m] of marks.entries()) {
      if (m.owner === elimPid) {
        marks.set(k, { owner: winnerPid, kind: m.kind });
      }
    }
    rebuildWallsFromCircles();
  }

  function eliminatePlayer(elimPid, eliminatorPid, reason) {
    if (!alive.get(elimPid)) return false;
    alive.set(elimPid, false);                // base disappears (not alive => not drawn, not conductive)
    transferEliminatedPieces(elimPid, eliminatorPid);

    showBanner(
      `ÉLIMINATION : ${elimPid}`,
      `${elimPid} éliminé par ${eliminatorPid} — ${reason}`,
      playerById(eliminatorPid).color
    );
    return true;
  }

  function checkVictory() {
    let aliveCount = 0, last = null;
    for (const p of PLAYERS) {
      if (alive.get(p.id)) { aliveCount++; last = p.id; }
    }
    if (aliveCount <= 1) {
      gameOver = true;
      if (last) {
        showBanner("C’EST GAGNÉ !", `Victoire : ${last}`, playerById(last).color);
        message = `C’est gagné ! Victoire : ${last}`;
      } else {
        showBanner("FIN", "Fin de partie.", "#eee");
        message = "Fin de partie.";
      }
      setBadges();
      requestRedraw();
      stopAI();
      return true;
    }
    return false;
  }

  function afterMove(actorPid, moveInfo) {
    if (gameOver) return;

    // Elimination ONLY if X is placed on an enemy base node
    if (moveInfo && moveInfo.kind === "X") {
      const owner = baseOwnerAt(moveInfo.ix, moveInfo.iy);
      if (owner && owner !== actorPid) {
        eliminatePlayer(owner, actorPid, "croix posée dans la base");
        if (checkVictory()) return;
      }
    }

    // No "coupure de courant" here (removed)
    checkVictory();
  }

  // ----------------------------
  // Turns / Scheduler
  // ----------------------------
  function nextAliveIndex(fromIdx) {
    for (let i = 1; i <= PLAYERS.length; i++) {
      const idx = (fromIdx + i) % PLAYERS.length;
      if (alive.get(PLAYERS[idx].id)) return idx;
    }
    return fromIdx;
  }

  function endTurn(silent=false) {
    if (gameOver) return;
    stopAI();
    if (typeof clearDrag === 'function') clearDrag();

    currentIdx = nextAliveIndex(currentIdx);
    movesLeft = MOVES_PER_TURN;
    if (!silent) message = "";
    setBadges();
    requestRedraw();
    maybeStartAITurn();
  }

  function maybeStartAITurn() {
    if (gameOver) return;
    const pid = currentPlayerId();
    if (!alive.get(pid)) { endTurn(true); return; }
    if (control.get(pid) === "AI") {
      scheduleAITick(0);
    }
  }

  function scheduleAITick(ms) {
    stopAI();
    aiTimer = setTimeout(aiTick, ms);
  }

  // ----------------------------
  // Defensive AI
  // ----------------------------
  function getThreatInfo(defPid) {
    // Menace = distance la plus courte entre une pièce ennemie et le centre de la base defPid
    const c = baseCenter(defPid);
    let bestD2 = Infinity;
    let bestPos = null;

    for (const [k, m] of marks.entries()) {
      if (!alive.get(m.owner)) continue;
      if (m.owner === defPid) continue;  // only enemy pieces
      const pos = parseKey(k);
      const d2 = dist2(pos, c);
      if (d2 < bestD2) { bestD2 = d2; bestPos = pos; }
    }

    return { threatD2: bestD2, threatPos: bestPos, baseCenter: c };
  }

    function generateAICandidates(pid) {
    const powered = computePoweredSet(pid);

    const circles = [];
    for (const [k, m] of marks.entries()) {
      if (!alive.get(m.owner)) continue;
      if (m.kind === "X" && m.owner !== pid) {
        if (canCircle(pid, k)) circles.push({ type:"CIRCLE", key:k });
      }
    }

    const crosses = [];
    const seen = new Set();
    for (const pk of powered) {
      const a = parseKey(pk);
      for (const d of dirs8) {
        const nx = a.ix + d.dx, ny = a.iy + d.dy;
        if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
        const kk = keyOf(nx, ny);
        if (seen.has(kk)) continue;
        seen.add(kk);
        if (marks.has(kk)) continue;
        if (!canPlaceCross(pid, nx, ny)) continue;
        crosses.push({ type:"CROSS", ix:nx, iy:ny });
      }
    }

    return { circles, crosses };
  }


  function hasOrthAdjacentOwnMark(pid, ix, iy){
    for (const d of neigh4){
      const nx = ix + d.dx, ny = iy + d.dy;
      if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
      const m = marks.get(keyOf(nx, ny));
      if (m && m.owner === pid) return true;
    }
    return false;
  }
  function orthAdjOwnCount(pid, ix, iy){
    let c = 0;
    for (const d of neigh4){
      const nx = ix + d.dx, ny = iy + d.dy;
      if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
      const m = marks.get(keyOf(nx, ny));
      if (m && m.owner === pid) c++;
    }
    return c;
  }

  // Encourage "straight-line" technique when it is useful (e.g., threading between enemy circles),
  // while still keeping a mild preference for diagonal (checker) placement by default.
  function lineTechniqueBonus(pid, ix, iy, target){
    const c = orthAdjOwnCount(pid, ix, iy);
    if (c <= 0) return 0;

    let bonus = 1800 * c; // reward extending an orthogonal chain
    if (target) {
      // Additional bonus when aligning toward a strategic point (threat or enemy base)
      if (ix === target.ix || iy === target.iy) bonus += 2200;
    }

    // Small penalty if it creates a rigid "cross junction" (too easy to wall off)
    if (c >= 2) bonus -= 900;
    return bonus;
  }

  function diagonalPreferenceBonus(ix, iy){
    // Motif en diagonale (damier) : évite les alignements qui facilitent la formation de murs adverses
    return ((((ix + iy) & 1) === 0) ? 2500 : 0);
  }

  function scoreMove(pid, mv, mode, threat, prof) {
    // capture de base ennemie = priorité absolue
    if (mv.type === "CROSS") {
      const owner = baseOwnerAt(mv.ix, mv.iy);
      if (owner && owner !== pid) return 1_000_000;
    }

    const myC = threat.baseCenter;
    const p = prof || aiProfile.get(pid) || AI_PROFILE_DEFS.BALANCED;
    const tgt = opponentTargetPoint(pid, p);

    if (mode === "DEFENSE") {
      // Défense : privilégier actions proches de sa base, surtout côté menace
      if (mv.type === "CIRCLE") {
        const pos = parseKey(mv.key);
        const nearBase = dist2(pos, myC);
        const towardThreat = threat.threatPos ? dist2(pos, threat.threatPos) : 999999;

        // voler près base est très fort
        let s = 200_000;
        s += (nearBase <= SHIELD_RADIUS2) ? 90_000 : 0;
        s += (nearBase <= DEFENSE_RADIUS2) ? 40_000 : 0;

        // bonus si le vol est près de la menace (pour casser une infiltration)
        s += (towardThreat <= 16) ? 30_000 : 0; // 4^2

        // un petit biais pour rester "compact"
        s -= nearBase * 6;
        return s;
      }

      if (mv.type === "CROSS") {
        const pos = { ix: mv.ix, iy: mv.iy };
        const nearBase = dist2(pos, myC);
        const towardThreat = threat.threatPos ? dist2(pos, threat.threatPos) : 999999;

        // En défense : on NE perd PAS de temps à "encercler" la base.
        // On place plutôt des croix dans l'axe de la menace (ou vers l'extérieur), et en diagonale (damier),
        // en évitant les alignements orthogonaux qui favorisent la formation de murs adverses.
        let s = 110_000;

        // priorité : casser l'infiltration (se rapprocher de la menace), pas coller à la base
        s += (towardThreat <= 25) ? 70_000 : 0;   // 5^2
        s += (towardThreat <= 9)  ? 55_000 : 0;   // 3^2

        // forte pénalité : croix trop proches de la base en mode défense (le "ring" est contre-productif)
        if (nearBase <= SHIELD_RADIUS2) s -= 120_000;
        else if (nearBase <= DEFENSE_RADIUS2) s -= 35_000;

        // pattern diagonal (par défaut)
        s += diagonalPreferenceBonus(mv.ix, mv.iy) * p.diagWeight;

        // évite les lignes (adjacence orthogonale à ses propres marques)
        s += lineTechniqueBonus(pid, mv.ix, mv.iy, threat.threatPos || myC) * p.lineWeight;

        // léger biais : ne pas s'éloigner infiniment (mais bien moins que l'ancien "bouclier")
        s -= nearBase * 6;

        return s;
      }
    }

    // Attaque (mode normal) — objectif: envahir une base (CROSS prioritaire).
    if (mv.type === "CIRCLE") {
      const pos = parseKey(mv.key);
      const d2 = dist2(pos, tgt);

      // Les cercles sont "tactiques" : utiles surtout près de la base cible (ou pour casser un verrou).
      // Loin de la base cible, c'est généralement une perte de tempo => pénalité.
      let s = 125_000 - Math.sqrt(d2) * 520; // décroît avec la distance
      if (d2 > 144) s -= 55_000;             // > 12 nœuds : trop loin
      if (d2 > 400) s -= 35_000;             // > 20 nœuds : encore moins logique

      // Biais profil: en attaque, on limite encore la fréquence des cercles
      s -= (1.0 - p.circleBiasAttack) * 45_000;

      return s;
    }

    if (mv.type === "CROSS") {
      const pos = { ix: mv.ix, iy: mv.iy };
      const d2 = dist2(pos, tgt);

      // Priorité claire : progresser vers la base cible
      let s = 95_000 - Math.sqrt(d2) * 620;

      // Motif diagonal (évite des murs faciles) — pondéré par profil
      s += diagonalPreferenceBonus(mv.ix, mv.iy) * p.diagWeight;

      // Technique en ligne: utile pour "passer" entre des ronds / prolonger une chaîne — pondéré
      s += lineTechniqueBonus(pid, mv.ix, mv.iy, tgt) * p.lineWeight;

      // Biais profil: plus le profil est "CROSS-first", plus on boost les croix en attaque
      s += (1.0 - p.circleBiasAttack) * 18_000;

      return s;
    }

    return -Infinity;
  }


function pickAIMoveNormal(pid) {
  const { circles, crosses } = generateAICandidates(pid);

  const prof = aiProfile.get(pid) || AI_PROFILE_DEFS.BALANCED;

  // Défense si menace proche
  const threat = getThreatInfo(pid);
  const mode = (threat.threatD2 <= DEFENSE_RADIUS2) ? "DEFENSE" : "ATTACK";

  const actions = [];
  for (const c of circles) actions.push(c);
  for (const x of crosses) actions.push(x);

  if (!actions.length) return { mv:null, mode, threat };

  // Sélection: on score TOUT et on choisit le meilleur (avec une petite part d'aléa par profil).
  // Objectif: envahir une base (attaque), et stopper une infiltration (défense).
  let best = null;
  let bestS = -Infinity;

  for (const mv of actions) {
    let s = scoreMove(pid, mv, mode, threat, prof);

    // Petit bruit pour éviter que toutes les IA prennent exactement les mêmes décisions
    s += (Math.random() - 0.5) * (prof.noise || 1200);

    // En ATTACK: limiter les cercles non tactiques (en plus du scoring) via un gate léger
    if (mode === "ATTACK" && mv.type === "CIRCLE") {
      if (Math.random() > (prof.circleBiasAttack || 0.10)) s -= 35_000;
    }
    // En DEFENSE: autoriser davantage les cercles
    if (mode === "DEFENSE" && mv.type === "CIRCLE") {
      if (Math.random() < (prof.circleBiasDefense || 0.60)) s += 8_000;
    }

    if (s > bestS) { bestS = s; best = mv; }
  }

  return { mv: best, mode, threat };
}
// ----------------------------
// IA Expert Beam Search (volet Expert)
// - chaque IA a déjà un profil différent via aiProfile (RAIDER/BALANCED/SWARM/SIEGER)
// - Beam Search simule plusieurs coups du même joueur (dans son tour) pour choisir le meilleur 1er coup.
// - Objectif prioritaire: envahir / couper le réseau adverse via ronds quand c'est opportuniste.
// ----------------------------

function cloneMarks(src){
  const m = new Map();
  for (const [k,v] of src.entries()) m.set(k, { owner: v.owner, kind: v.kind });
  return m;
}
function cloneSimpleMap(src){
  const m = new Map();
  for (const [k,v] of src.entries()) m.set(k, v);
  return m;
}

function rebuildWallsFromCircles_state(st) {
  st.walls.clear();
  for (const [k, m] of st.marks.entries()) {
    if (m.kind !== "O") continue;
    const a = parseKey(k);
    for (const d of neigh4) {
      const b = { ix: a.ix + d.dx, iy: a.iy + d.dy };
      if (b.ix < 0 || b.iy < 0 || b.ix >= NODES || b.iy >= NODES) continue;
      const mb = st.marks.get(keyOf(b.ix, b.iy));
      if (mb && mb.kind === "O" && mb.owner === m.owner) {
        const ek = edgeKey(a, b);
        st.walls.set(ek, m.owner);
      }
    }
  }
}

function isBlockedByEnemyWall_state(st, from, to, pid, dx, dy) {
  const isOrth = (Math.abs(dx) + Math.abs(dy)) === 1;
  if (!isOrth) return false;
  const ek = edgeKey(from, to);
  const owner = st.walls.get(ek);
  if (!owner) return false;
  return owner !== pid;
}

function conductiveForPlayer_state(st, ix, iy, pid) {
  const k = keyOf(ix, iy);
  const m = st.marks.get(k);
  if (m && m.owner === pid) return true;
  if (!st.alive.get(pid)) return false;
  return inBase(ix, iy, baseRectFor(pid));
}

function computePoweredSet_state(st, pid) {
  const powered = new Set();
  const q = [];
  if (!st.alive.get(pid)) return powered;

  const base = baseRectFor(pid);
  for (let y = base.iy; y <= base.iy + base.cells; y++) {
    for (let x = base.ix; x <= base.ix + base.cells; x++) {
      const k = keyOf(x, y);
      powered.add(k);
      q.push({ix:x, iy:y});
    }
  }

  while (q.length) {
    const cur = q.shift();
    for (const d of dirs8) {
      const nx = cur.ix + d.dx, ny = cur.iy + d.dy;
      if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
      if (!conductiveForPlayer_state(st, nx, ny, pid)) continue;
      if (isBlockedByEnemyWall_state(st, cur, {ix:nx, iy:ny}, pid, d.dx, d.dy)) continue;
      const nk = keyOf(nx, ny);
      if (powered.has(nk)) continue;
      powered.add(nk);
      q.push({ix:nx, iy:ny});
    }
  }
  return powered;
}

function hasAdjacentFriendlyOrBase_state(st, pid, ix, iy) {
  if (!st.alive.get(pid)) return false;
  const base = baseRectFor(pid);
  for (const d of dirs8) {
    const nx = ix + d.dx, ny = iy + d.dy;
    if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
    if (inBase(nx, ny, base)) return true;
    const m = st.marks.get(keyOf(nx, ny));
    if (m && m.owner === pid) return true;
  }
  return false;
}

function canPlaceCross_state(st, pid, ix, iy) {
  if (st.gameOver || !st.alive.get(pid)) return false;
  const k = keyOf(ix, iy);
  if (st.marks.has(k)) return false;
  if (isOwnBase(pid, ix, iy)) return false;

  // test connectivité
  st.marks.set(k, { owner: pid, kind:"X" });
  rebuildWallsFromCircles_state(st);
  const powered = computePoweredSet_state(st, pid);
  const ok = powered.has(k);
  st.marks.delete(k);
  rebuildWallsFromCircles_state(st);
  return ok;
}

function canCircle_state(st, pid, key) {
  if (st.gameOver || !st.alive.get(pid)) return false;
  const t = st.marks.get(key);
  if (!t || t.owner === pid || t.kind !== "X") return false;
  const {ix, iy} = parseKey(key);
  if (!hasAdjacentFriendlyOrBase_state(st, pid, ix, iy)) return false;

  st.marks.set(key, { owner: pid, kind:"O" });
  rebuildWallsFromCircles_state(st);
  const powered = computePoweredSet_state(st, pid);
  const ok = powered.has(key);
  st.marks.set(key, t);
  rebuildWallsFromCircles_state(st);
  return ok;
}

function baseOwnerAt_state(st, ix, iy) {
  for (const p of PLAYERS) {
    if (!st.alive.get(p.id)) continue;
    if (inBase(ix, iy, baseRectFor(p.id))) return p.id;
  }
  return null;
}

function applyMove_state(st, pid, mv) {
  if (mv.type === "CROSS") {
    const k = keyOf(mv.ix, mv.iy);
    st.marks.set(k, { owner: pid, kind:"X" });
    st.started.set(pid, true);
    // capture base
    const owner = baseOwnerAt_state(st, mv.ix, mv.iy);
    if (owner && owner !== pid) {
      st.alive.set(owner, false);
      // si 1 seul survivant => gameOver
      const aliveIds = PLAYERS.filter(p => st.alive.get(p.id)).map(p=>p.id);
      if (aliveIds.length <= 1) st.gameOver = true;
    }
  } else {
    st.marks.set(mv.key, { owner: pid, kind:"O" });
    st.started.set(pid, true);
  }
  rebuildWallsFromCircles_state(st);
}

function generateAICandidates_state(st, pid) {
  const powered = computePoweredSet_state(st, pid);
  const circles = [];
  for (const [k, m] of st.marks.entries()) {
    if (!st.alive.get(m.owner)) continue;
    if (m.kind === "X" && m.owner !== pid) {
      if (canCircle_state(st, pid, k)) circles.push({ type:"CIRCLE", key:k });
    }
  }
  const crosses = [];
  const seen = new Set();
  for (const pk of powered) {
    const a = parseKey(pk);
    for (const d of dirs8) {
      const nx = a.ix + d.dx, ny = a.iy + d.dy;
      if (nx < 0 || ny < 0 || nx >= NODES || ny >= NODES) continue;
      const kk = keyOf(nx, ny);
      if (seen.has(kk)) continue;
      seen.add(kk);
      if (st.marks.has(kk)) continue;
      if (!canPlaceCross_state(st, pid, nx, ny)) continue;
      crosses.push({ type:"CROSS", ix:nx, iy:ny });
    }
  }
  return { circles, crosses };
}

// Heuristique d'évaluation locale pour Beam (reste compatible avec tes profils)
function evalMove_state(st, pid, mv, prof) {
  // capture immédiate
  if (mv.type === "CROSS") {
    const owner = baseOwnerAt_state(st, mv.ix, mv.iy);
    if (owner && owner !== pid) return 1_000_000_000;
  }

  // cible: point de base adverse choisi par la logique existante (profil)
  const tgt = opponentTargetPoint(pid, prof);
  const pos = (mv.type === "CROSS") ? {ix: mv.ix, iy: mv.iy} : parseKey(mv.key);

  // attaque: distance Chebyshev au point cible
  const d = Math.max(Math.abs(pos.ix - tgt.ix), Math.abs(pos.iy - tgt.iy));
  let sAttack = 120_000 - d * 2400;

  // ronds = "couper" : bonus si proche du réseau adverse (opportuniste)
  if (mv.type === "CIRCLE") {
    // bonus si cercle proche base adverse ou proche cible
    const d2 = dist2(pos, tgt);
    sAttack += 25_000 - d2 * 35;
    // léger coût pour éviter trop de ronds inutiles
    sAttack -= 10_000;
  } else {
    // croix: bonus de progression (frontier)
    sAttack += diagonalPreferenceBonus(pos.ix, pos.iy) * (prof.diagWeight || 0.7);
    if (hasOrthAdjacentOwnMark(pid, pos.ix, pos.iy)) sAttack += 9_000 * (prof.lineWeight || 1.0);
  }

  // défense: très légère (éviter suicide de réseau)
  const myC = baseCenter(pid);
  const nearBase = dist2(pos, myC);
  let sDefense = 0;
  if (nearBase <= SHIELD_RADIUS2 && mv.type === "CROSS") sDefense -= 18_000;

  // noise pour casser égalités (et éviter mirroring)
  const noise = (Math.random() - 0.5) * (AI_BEAM.tieNoise * 100_000);

  return AI_BEAM.wAttack * sAttack + AI_BEAM.wDefense * sDefense + noise;
}

function pickAIMoveBeam(pid) {
  const prof = aiProfile.get(pid) || AI_PROFILE_DEFS.BALANCED;
  const depth = Math.max(1, Math.min(AI_BEAM.depth, movesLeft));

  // état initial cloné
  const root = {
    marks: cloneMarks(marks),
    walls: cloneSimpleMap(walls),
    alive: cloneSimpleMap(alive),
    started: cloneSimpleMap(started),
    gameOver: gameOver
  };
  rebuildWallsFromCircles_state(root);

  // beam élément: { st, score, firstMove }
  let beam = [{ st: root, score: 0, firstMove: null }];

  for (let ply = 0; ply < depth; ply++) {
    const expanded = [];

    for (const node of beam) {
      if (node.st.gameOver) { expanded.push(node); continue; }

      const { circles, crosses } = generateAICandidates_state(node.st, pid);
      const actions = crosses.concat(circles);
      if (!actions.length) {
        expanded.push(node);
        continue;
      }

      // scorings immédiats pour trier et limiter la branche
      const scored = actions.map(mv => ({ mv, s: evalMove_state(node.st, pid, mv, prof) }))
                            .sort((a,b)=>b.s-a.s)
                            .slice(0, AI_BEAM.maxBranch);

      for (const it of scored) {
        const st2 = {
          marks: cloneMarks(node.st.marks),
          walls: cloneSimpleMap(node.st.walls),
          alive: cloneSimpleMap(node.st.alive),
          started: cloneSimpleMap(node.st.started),
          gameOver: node.st.gameOver
        };
        applyMove_state(st2, pid, it.mv);
        expanded.push({
          st: st2,
          score: node.score + it.s,
          firstMove: node.firstMove || it.mv
        });
      }
    }

    expanded.sort((a,b)=>b.score-a.score);
    beam = expanded.slice(0, AI_BEAM.beamWidth);
    if (!beam.length) break;
  }

  // meilleur scénario => premier coup
  const best = beam[0];
  return { mv: best.firstMove, mode: "ATTACK", threat: { baseCenter: baseCenter(pid), threatPos: null, threatD2: Infinity } };
}

// Dispatcher: Normal vs Expert Beam
function pickAIMove(pid) {
  if (expertMode) return pickAIMoveBeam(pid);
  return pickAIMoveNormal(pid);
}


  function aiTick() {
    aiTimer = null;
    if (gameOver) return;

    const pid = currentPlayerId();
    if (!alive.get(pid)) { endTurn(true); return; }
    if (control.get(pid) !== "AI") return;
    if (movesLeft <= 0) { endTurn(true); return; }

    const pick = pickAIMove(pid);
    const mv = pick.mv;

    if (!mv) {
      message = `IA ${pid} : aucun coup possible, fin de tour.`;
      setBadges();
      requestRedraw();
      endTurn(true);
      return;
    }

    let moveInfo = null;
    if (mv.type === "CIRCLE") moveInfo = placeCircle(pid, mv.key);
    else moveInfo = placeCross(pid, mv.ix, mv.iy);

    movesLeft--;
    afterMove(pid, moveInfo);

    message = (pick.mode === "DEFENSE")
      ? `IA ${pid} (défense)`
      : `IA ${pid} (attaque)`;

    setBadges();
    requestRedraw();

    if (gameOver) return;

    if (movesLeft <= 0) {
      endTurn(true);
      return;
    }

    scheduleAITick(90);
  }

  // ----------------------------
  // Human move
  // ----------------------------
  function validateMoveHuman() {
    if (gameOver) return;

    const pid = currentPlayerId();
    if (!alive.get(pid)) { endTurn(true); return; }
    if (control.get(pid) !== "HUMAN") return;
    if (movesLeft <= 0) { endTurn(true); return; }

    const cur = activeCursor();
    const k = keyOf(cur.ix, cur.iy);
    const existing = marks.get(k);

    let moveInfo = null;

    if (!existing) {
      if (!canPlaceCross(pid, cur.ix, cur.iy)) {
        message = isOwnBase(pid, cur.ix, cur.iy)
          ? "Interdit : pas de croix dans ta base."
          : "Coup refusé : doit rester alimenté (connecté à ta base).";
        setBadges();
        requestRedraw();
        return;
      }
      moveInfo = placeCross(pid, cur.ix, cur.iy);
    } else if (existing.owner !== pid && existing.kind === "X") {
      if (!canCircle(pid, k)) {
        message = "Rond interdit : adjacency base/pièce + rester alimenté.";
        setBadges();
        requestRedraw();
        return;
      }
      moveInfo = placeCircle(pid, k);
    } else {
      message = "Action impossible ici.";
      setBadges();
      requestRedraw();
      return;
    }

    movesLeft--;
    afterMove(pid, moveInfo);

    message = "";
    setBadges();
    requestRedraw();

    if (gameOver) return;
    if (movesLeft <= 0) endTurn(true);
  }

  // ----------------------------
  // UI
  // ----------------------------
  function setBadges() {
    const p = currentPlayer();
    document.getElementById("turn").textContent = `Joueur: ${p.id}`;
    document.getElementById("moves").textContent = `Coups restants: ${movesLeft}`;
    renderPlayersRow();
    renderStatus();
  }

  function renderPlayersRow() {
    const row = document.getElementById("playersRow");
    row.innerHTML = "";

    for (const p of PLAYERS) {
      const chip = document.createElement("div");
      chip.className = "pchip";
      chip.style.opacity = alive.get(p.id) ? "1" : "0.35";
      chip.style.borderColor = (p.id === currentPlayerId()) ? p.color : "#333";
      chip.style.boxShadow = (p.id === currentPlayerId()) ? `0 0 0 2px ${p.color}33 inset` : "none";

      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = p.color;

      const label = document.createElement("span");
      const st = alive.get(p.id) ? "EN JEU" : "ÉLIMINÉ";
      label.textContent = `${p.name} — ${st}`;

      const sel = document.createElement("select");
      sel.innerHTML = `<option value="HUMAN">Humain</option><option value="AI">IA</option>`;
      sel.value = control.get(p.id);
      sel.addEventListener("change", () => {
        control.set(p.id, sel.value);
        stopAI();
        setBadges();
        requestRedraw();
        maybeStartAITurn();
      });

      chip.appendChild(dot);
      chip.appendChild(label);
      chip.appendChild(sel);
      row.appendChild(chip);
    }
  }

  function renderStatus() {
    const pid = currentPlayerId();
    if (gameOver) {
      document.getElementById("status").innerHTML = `<span class="ok">${message}</span>`;
      return;
    }
    if (control.get(pid) === "AI") {
      document.getElementById("status").innerHTML = `<span class="warn">IA ${pid} joue… ${message ? "— " + message : ""}</span>`;
      return;
    }
    if (message) {
      document.getElementById("status").innerHTML = `<span class="warn">${message}</span>`;
      return;
    }
    document.getElementById("status").innerHTML = `<span class="ok">À toi de jouer.</span>`;
  }

  // ----------------------------
  // Drawing
  // ----------------------------
  let rafPending = false;
  function requestRedraw() {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      rafPending = false;
      redraw();
    });
  }
function isInAnyBaseNode(ix, iy) {
  for (const p of PLAYERS) {
    if (!alive.get(p.id)) continue;
    const b = baseRectFor(p.id);
    
    // Debug : affiche les valeurs une seule fois
    if (ix === 0 && iy === 0) {
      console.log(`Base ${p.id}: ix=${b.ix}, iy=${b.iy}, cells=${b.cells}`);
      console.log(`NODES = ${NODES}`);
    }
    
    if (ix >= b.ix && ix <= b.ix + b.cells && 
        iy >= b.iy && iy <= b.iy + b.cells) {
      return true;
    }
  }
  return false;
}

function drawGrid() {
  ctx.save();
  ctx.clearRect(0, 0, displayW, displayH);
  ctx.fillStyle = boardBg;
  ctx.fillRect(0, 0, displayW, displayH);

  const gridLine = (boardBg === "#0b0b0b") ? "#5a5a5a" : "#1f1f1f";
  ctx.strokeStyle = gridLine;
  ctx.lineWidth = 1;
  for (let i = 0; i <= GRID_CELLS; i++) {
    const x = MARGIN_PX + i * CELL_PX;
    ctx.beginPath(); ctx.moveTo(x, MARGIN_PX); ctx.lineTo(x, MARGIN_PX + GRID_CELLS * CELL_PX); ctx.stroke();
    const y = MARGIN_PX + i * CELL_PX;
    ctx.beginPath(); ctx.moveTo(MARGIN_PX, y); ctx.lineTo(MARGIN_PX + GRID_CELLS * CELL_PX, y); ctx.stroke();
  }
  
  // Dessiner les points aux intersections (sauf dans les bases)
  ctx.fillStyle = (boardBg === "#0b0b0b") ? "#4a4a4a" : "#2e2e2e";
  for (let y = 0; y < NODES; y++) {
    for (let x = 0; x < NODES; x++) {
      // Enlève les petits points sur les bases
      if (isInAnyBaseNode(x, y)) continue;

      const p = nodeToPx(x, y);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 1.1, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  ctx.restore();
}

  function drawBase(pid) {
    if (!alive.get(pid)) return;
    const p = playerById(pid);
    const base = baseRectFor(pid);
    const tl = nodeToPx(base.ix, base.iy);
    const br = nodeToPx(base.ix + base.cells, base.iy + base.cells);

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = p.color;
    ctx.fillRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);

    ctx.globalAlpha = 1;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);

    ctx.fillStyle = p.color;
   ctx.font = "bold 14px 'Orbitron', sans-serif";
// Calculer le centre du rectangle
const centerX = tl.x + (br.x - tl.x) / 2;
const centerY = tl.y + (br.y - tl.y) / 2;

// Dessiner "Base" centré en haut
ctx.textAlign = "center";
ctx.fillText("Base", centerX, centerY - 5);

// Dessiner la lettre en dessous
ctx.fillText(pid, centerX, centerY + 10);

ctx.textAlign = "left"; // Réinitialiser
ctx.restore();
   
  }

  function drawCircuitGlow(pid, poweredSet) {
    const p = playerById(pid);
    for (const pass of [0, 1]) {
      ctx.save();
      ctx.strokeStyle = p.color;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      if (pass === 0) { ctx.globalAlpha = HALO_ALPHA_WIDE; ctx.lineWidth = HALO_WIDE; }
      else { ctx.globalAlpha = HALO_ALPHA_THIN; ctx.lineWidth = HALO_THIN; }

      for (const k of poweredSet) {
        const a = parseKey(k);
        for (const d of dirs8) {
          const b = { ix: a.ix + d.dx, iy: a.iy + d.dy };
          if (b.ix < 0 || b.iy < 0 || b.ix >= NODES || b.iy >= NODES) continue;
          const nk = keyOf(b.ix, b.iy);
          if (!poweredSet.has(nk)) continue;
          if (isBlockedByEnemyWall(a, b, pid, d.dx, d.dy)) continue;
          if (k >= nk) continue;
 if (isInAnyBaseNode(a.ix, a.iy) && isInAnyBaseNode(b.ix, b.iy)) continue;
          const p1 = nodeToPx(a.ix, a.iy);
          const p2 = nodeToPx(b.ix, b.iy);
          ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
        }
      }
      ctx.restore();
    }
  }

  function drawWall(edgeK, ownerPid, poweredOwnerSet) {
    const owner = playerById(ownerPid);
    const [k1, k2] = edgeK.split("|");
    const a = parseKey(k1), b = parseKey(k2);
    const p1 = nodeToPx(a.ix, a.iy);
    const p2 = nodeToPx(b.ix, b.iy);
    const powered = poweredOwnerSet.has(k1) && poweredOwnerSet.has(k2);

    ctx.save();
    ctx.strokeStyle = owner.color;
    ctx.lineCap = "round";
    ctx.globalAlpha = powered ? 0.25 : 0.18;
    ctx.lineWidth = powered ? 13 : 11;
    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();

    ctx.globalAlpha = powered ? 0.98 : 0.88;
    ctx.lineWidth = powered ? 7 : 5.5;
    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
    ctx.restore();
  }

  function drawCross(ix, iy, color, powered=false) {
    const p = nodeToPx(ix, iy);
    const s = 6;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = powered ? 3.2 : 2.0;
    ctx.beginPath();
    ctx.moveTo(p.x - s, p.y - s); ctx.lineTo(p.x + s, p.y + s);
    ctx.moveTo(p.x + s, p.y - s); ctx.lineTo(p.x - s, p.y + s);
    ctx.stroke();
    if (powered) {
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawCircle(ix, iy, color, powered=false) {
    const p = nodeToPx(ix, iy);
    ctx.save();
    ctx.globalAlpha = powered ? 0.38 : 0.24;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(p.x, p.y, 9.6, 0, Math.PI*2); ctx.fill();

    ctx.globalAlpha = 1;
    ctx.strokeStyle = color;
    ctx.lineWidth = powered ? 3.0 : 1.9;
    ctx.beginPath(); ctx.arc(p.x, p.y, 9.6, 0, Math.PI*2); ctx.stroke();

    if (powered) {
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(p.x, p.y, 13, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawCursor(pid, active=false) {
    const p = playerById(pid);
    const cur = cursors.get(pid);
    const pos = nodeToPx(cur.ix, cur.iy);

    ctx.save();
    if (!active) {
      ctx.strokeStyle = p.color;
      ctx.globalAlpha = alive.get(pid) ? 0.28 : 0.10;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(pos.x, pos.y, 8.5, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      return;
    }

    const pidNow = currentPlayerId();
    const kk = keyOf(cur.ix, cur.iy);
    const existing = marks.get(kk);
    let ok = false;
    // Pendant un drag-diagonal: on se base sur la simulation virtuelle (dragOkPath)
    if (typeof dragPlacing !== "undefined" && dragPlacing && dragMoved) {
      ok = (dragOkPath && dragOkPath.length > 0);
    } else {
      if (!existing) ok = canPlaceCross(pidNow, cur.ix, cur.iy);
      else if (existing.owner !== pidNow && existing.kind === "X") ok = canCircle(pidNow, kk);
    }

    ctx.strokeStyle = ok ? "#9dffb6" : "#ff8a8a";
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(pos.x, pos.y, 13, 0, Math.PI*2); ctx.stroke();

    ctx.strokeStyle = p.color;
    ctx.globalAlpha = 0.9;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(pos.x, pos.y, 6.2, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function redraw() {
    rebuildWallsFromCircles();
    const powered = new Map();
    for (const p of PLAYERS) powered.set(p.id, computePoweredSet(p.id));

    drawGrid();
    for (const p of PLAYERS) drawBase(p.id);

    for (const p of PLAYERS) {
      if (!alive.get(p.id)) continue;
      if (!started.get(p.id)) continue;
      drawCircuitGlow(p.id, powered.get(p.id));
    }

    for (const [ek, ownerPid] of walls.entries()) {
      drawWall(ek, ownerPid, powered.get(ownerPid));
    }

    for (const [k, m] of marks.entries()) {
      const {ix, iy} = parseKey(k);
      const col = playerById(m.owner).color;
      const isPow = powered.get(m.owner).has(k);
      if (m.kind === "X") drawCross(ix, iy, col, isPow);
      else drawCircle(ix, iy, col, isPow);
    }

    
    // Preview "ligne" (drag clic gauche) : croix fantômes (sans consommer de coups)
    if (typeof dragPlacing !== "undefined" && dragPlacing && dragPath && dragPath.length) {
      const pidNow = currentPlayerId();
      if (control.get(pidNow) !== "AI" && alive.get(pidNow)) {
        const col = playerById(pidNow).color;

        // okNodes = posables (simulation), reste = bloqué
        const okSet = new Set((dragOkPath || []).map(n => n.k));

        ctx.save();
        // OK en couleur joueur
        ctx.globalAlpha = 0.28;
        for (let i=0;i<dragPath.length;i++) {
          const node = dragPath[i];
          const ex = marks.get(node.k);

          // Si le point de départ est déjà à nous, il sert d’ancre (pas une pose)
          if (ex) {
            if (i === 0 && ex.owner === pidNow) continue;
            break; // stop à la 1ère occupation bloquante
          }

          // Si le point de départ est vide, il PEUT être posé (et sera dans okSet si possible)
          if (okSet.has(node.k)) drawCross(node.ix, node.iy, col, false);
          else break; // stop strict au 1er non-posable
        }

        // le "bloqué" immédiat (si existe) en rouge léger
        ctx.globalAlpha = 0.18;
        for (let i=0;i<dragPath.length;i++) {
          const node = dragPath[i];
          const ex = marks.get(node.k);
          if (ex) {
            if (i === 0 && ex.owner === pidNow) continue;
            break;
          }
          if (!okSet.has(node.k)) { drawCross(node.ix, node.iy, "#ff6b6b", false); break; }
        }
        ctx.restore();
      }
    }

    for (const p of PLAYERS) drawCursor(p.id, p.id === currentPlayerId());
  }

  // ----------------------------
  // Inputs / Buttons
  // ----------------------------
  function onKey(e) {
    const k = e.key.toLowerCase();
    if (k === " ") e.preventDefault();
    if (gameOver) return;

    const pid = currentPlayerId();
    if (!alive.get(pid)) { endTurn(true); return; }
    if (control.get(pid) === "AI") return;

    const cur = activeCursor();
    if (k === "o") { cur.iy = clamp(cur.iy - 1, 0, NODES - 1); message=""; setBadges(); requestRedraw(); return; }
    if (k === "l") { cur.iy = clamp(cur.iy + 1, 0, NODES - 1); message=""; setBadges(); requestRedraw(); return; }
    if (k === "k") { cur.ix = clamp(cur.ix - 1, 0, NODES - 1); message=""; setBadges(); requestRedraw(); return; }
    if (k === "m") { cur.ix = clamp(cur.ix + 1, 0, NODES - 1); message=""; setBadges(); requestRedraw(); return; }
    if (k === " ") { validateMoveHuman(); return; }
    if (k === "b") { toggleBoardBg(); return; }
    if (k === "x") { toggleExpertMode(); return; }
    if (k === "w") { endTurn(); return; }
  }

  document.getElementById("endturn").addEventListener("click", () => endTurn());
  document.getElementById("reset").addEventListener("click", reset);
  document.getElementById("togglebg").addEventListener("click", toggleBoardBg);
  document.getElementById("toggleExpert").addEventListener("click", toggleExpertMode);
  window.addEventListener("keydown", onKey);
  // ----------------------------
  // Mouse controls
  //  - Survol : déplace le curseur
  //  - Clic gauche : pose 1 coup (comme Espace)
  //  - Clic gauche maintenu + déplacement : trace une LIGNE STRICTEMENT DIAGONALE (preview), et on valide tout au relâchement
  //  - Clic droit : fin de tour
  // ----------------------------
  let dragPlacing = false;
  let dragMoved = false;
  let dragStart = null;      // {ix,iy}
  let dragPath = [];         // [{ix,iy,k}]
  let dragOkPath = [];       // sous-ensemble posable (simulation virtuelle)

  function clearDrag() {
    dragPlacing = false;
    dragMoved = false;
    dragStart = null;
    dragPath = [];
    dragOkPath = [];
  }

  function sign(v){ return v < 0 ? -1 : (v > 0 ? 1 : 0); }

  // Projette la position courante sur la diagonale la plus proche (↘↗) passant par dragStart
  function projectToNearestDiagonal(start, cur){
    const dx = cur.ix - start.ix;
    const dy = cur.iy - start.iy;

    // diag +1 : (x+u, y+u)
    let u1 = Math.round(((dx) + (dy)) / 2);
    let c1 = { ix: clamp(start.ix + u1, 0, NODES - 1), iy: clamp(start.iy + u1, 0, NODES - 1) };

    // diag -1 : (x+u, y-u)
    let u2 = Math.round(((dx) - (dy)) / 2);
    let c2 = { ix: clamp(start.ix + u2, 0, NODES - 1), iy: clamp(start.iy - u2, 0, NODES - 1) };

    // Re-clamp cohérent (si clamp a cassé l’égalité |dx|=|dy|, on ré-ajuste au mieux)
    // On s’assure juste que c1/c2 restent dans la grille; buildDiagonalPath gère le pas.
    const e1 = (cur.ix - c1.ix)*(cur.ix - c1.ix) + (cur.iy - c1.iy)*(cur.iy - c1.iy);
    const e2 = (cur.ix - c2.ix)*(cur.ix - c2.ix) + (cur.iy - c2.iy)*(cur.iy - c2.iy);

    return (e1 <= e2) ? c1 : c2;
  }

  function buildDiagonalPath(a, b){
    const dx = b.ix - a.ix;
    const dy = b.iy - a.iy;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    const sx = sign(dx);
    const sy = sign(dy);
    const out = [];
    for(let i=0;i<=steps;i++){
      const ix = a.ix + i*sx;
      const iy = a.iy + i*sy;
      if(ix<0||iy<0||ix>=NODES||iy>=NODES) break;
      out.push({ ix, iy, k: keyOf(ix, iy) });
    }
    return out;
  }

  function updateDiagonalDragPath(curNode){
    if(!dragStart) return;
    const end = projectToNearestDiagonal(dragStart, curNode);
    const path = buildDiagonalPath(dragStart, end);
    dragPath = path;
    dragMoved = (path.length > 1);

    // Recalcule la ligne "posable" en mode VIRTUEL (connexion qui se propage le long de la diagonale)
    // IMPORTANT : on ne pose rien réellement ici, on ne fait qu'une simulation.
    const pidNow = currentPlayerId();
    if (dragPlacing && dragMoved && control.get(pidNow) !== "AI" && alive.get(pidNow)) {
      dragOkPath = computeVirtualPlaceableDrag(pidNow, dragPath);
    } else {
      dragOkPath = [];
    }
  }

  // Simulation "virtuelle" pour le drag:
  // On tente de poser des croix (temporairement) dans l'ordre pour que la connexion
  // se propage le long de la diagonale. On s'arrête au 1er blocage.
  function computeVirtualPlaceableDrag(pid, path){
    // path inclut [start..end]. On essaie de poser des CROIX virtuelles dans l’ordre
    // en permettant que le 1er nœud soit lui aussi une pose (si vide et connectable).
    const tempKeys = [];
    const okNodes = [];
    const maxToPlace = movesLeft; // limité par coups restants

    function rollback(){
      for (const k of tempKeys) marks.delete(k);
    }

    // On avance le long de la diagonale : 
    // - si nœud occupé par notre réseau (croix/rond) et POWERED => sert d’ancre, on continue
    // - si nœud vide => on tente de poser une croix virtuelle, et on stop au 1er blocage
    for (let i = 0; i < path.length; i++){
      if (okNodes.length >= maxToPlace) break;
      const node = path[i];

      // Occupé ?
      const existing = marks.get(node.k);
      if (existing) {
        // Si c’est à nous, on peut s’en servir comme ancre, mais seulement si c’est alimenté
        if (existing.owner === pid) {
          const powered = computePoweredSet(pid);
          if (!powered.has(node.k)) { break; } // pas alimenté => ligne invalide
          continue; // ancre OK
        }
        // occupé par autre chose => stop strict
        break;
      }

      // Interdit de poser dans sa propre base (règle générale)
      if (isOwnBase(pid, node.ix, node.iy)) break;

      // Pose virtuelle
      marks.set(node.k, { owner: pid, kind:"X" });
      tempKeys.push(node.k);

      const powered = computePoweredSet(pid);
      if (powered.has(node.k)) {
        okNodes.push(node); // on garde la pose virtuelle pour aider les suivantes
      } else {
        // pas connecté -> on annule cette croix et stop strict
        marks.delete(node.k);
        tempKeys.pop();
        break;
      }
    }

    rollback();
    return okNodes;
  }


  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  canvas.addEventListener("mousemove", (e) => {
    if (gameOver) return;
    const pid = currentPlayerId();
    if (control.get(pid) === "AI") return;
    if (!alive.get(pid)) return;

    const n = mouseToNode(e.clientX, e.clientY);
    const cur = cursors.get(pid);
    cur.ix = n.ix;
    cur.iy = n.iy;

    if (dragPlacing) updateDiagonalDragPath(n);

    message = "";
    setBadges();
    requestRedraw();
  });

  canvas.addEventListener("mousedown", (e) => {
    if (gameOver) return;
    const pid = currentPlayerId();
    if (control.get(pid) === "AI") return;
    if (!alive.get(pid)) return;

    const n = mouseToNode(e.clientX, e.clientY);
    const cur = cursors.get(pid);
    cur.ix = n.ix;
    cur.iy = n.iy;

    if (e.button === 0) {
      // Démarre le drag diagonal : la validation se fait au relâchement.
      // Si l'utilisateur ne bouge pas => clic normal.
      clearDrag();
      dragPlacing = true;
      dragStart = { ix: n.ix, iy: n.iy };
      dragPath = [{ ix: n.ix, iy: n.iy, k: keyOf(n.ix, n.iy) }];
      dragMoved = false;
      dragOkPath = [];

      message = "";
      setBadges();
      requestRedraw();
      return;
    }

    if (e.button === 2) {
      endTurn();
      return;
    }
  });

  // Relâchement : si drag => on valide la "ligne" (CROIX uniquement) au relâchement
  window.addEventListener("mouseup", (e) => {
    if (e.button !== 0) return;
    if (!dragPlacing) return;

    const pid = currentPlayerId();
    if (gameOver || control.get(pid) === "AI" || !alive.get(pid)) { clearDrag(); return; }

    // si pas bougé => comportement original (un seul coup au clic)
    if (!dragMoved) {
      clearDrag();
      validateMoveHuman();
      return;
    }

    // sinon, on "valide" la ligne diagonale au relâchement :
    // on pose les croix RÉELLEMENT en se basant sur la simulation virtuelle (dragOkPath)
    dragPlacing = false;

    let placed = 0;
    if (!dragOkPath || dragOkPath.length === 0) {
      clearDrag();
      message = "Ligne invalide (pas de connexion possible).";
      setBadges();
      requestRedraw();
      return;
    }

    for (const node of dragOkPath) {
      if (gameOver) break;
      if (movesLeft <= 0) break;

      // Si déjà occupé => stop strict
      if (marks.has(node.k)) break;

      // Pose réelle d'une CROIX (même pipeline que validateMoveHuman)
      if (!canPlaceCross(pid, node.ix, node.iy)) break;
      const moveInfo = placeCross(pid, node.ix, node.iy);
      movesLeft--;
      afterMove(pid, moveInfo);
      placed++;

      if (gameOver) break;
    }

    clearDrag();

    message = placed > 0
      ? `Ligne validée: ${placed} croix posée(s).`
      : "Ligne invalide.";
    setBadges();
    requestRedraw();

    // Consistance avec les autres coups : si plus de coups, fin de tour auto
    if (!gameOver && movesLeft <= 0) endTurn(true);
  });


  // ----------------------------
  // Reset
  // ----------------------------
  function reset() {
    stopAI();
    if (typeof clearDrag === 'function') clearDrag();

    marks.clear();
    walls.clear();
    for (const p of PLAYERS) {
      alive.set(p.id, true);
      started.set(p.id, true); // tous démarrent avec une croix initiale
      cursors.set(p.id, { ...startNodeFor(p.id) });
    }

    // IA: profils distincts à chaque partie (évite le même schéma d'ouverture)
    assignAIProfiles();

    // croix initiales (une par joueur)
    for (const p of PLAYERS) {
      const s = startNodeFor(p.id);
      marks.set(keyOf(s.ix, s.iy), { owner: p.id, kind:"X" });
    }

    rebuildWallsFromCircles();

    currentIdx = 0;
    movesLeft = MOVES_PER_TURN;
    message = "";
    gameOver = false;

    setBadges();
    requestRedraw();
    maybeStartAITurn();
  }

  // Init
  reset();
})();
</script>
</body>
</html>
